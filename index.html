<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mahjong Solitaire – Final Release</title>
  <style>
    /* ====================== RESET & GLOBAL STYLES ====================== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    /* Use flex on the body so that the footer stays at the bottom */
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow-x: hidden;
    }
    h1 { 
      margin-bottom: 10px; 
    }
    button {
      padding: 8px 16px;
      margin: 4px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #28a745;
      color: #fff;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #218838;
    }
    
    /* ====================== BOARD CONTAINER ====================== */
    /* Our board container will serve as the game area on which tiles are placed. */
    #board-container {
      position: relative;
      margin: 0 auto;
      max-width: 800px;
      height: 600px;
      background-color: #2a2a2a;
      border: 2px solid #333;
    }
    
    /* ====================== TILE STYLING ====================== */
    .tile {
      position: absolute;
      width: 80px;
      height: 100px;
      background-color: #fff;
      border: 1px solid #888;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: bold;
      user-select: none;
      transition: opacity 0.3s ease;
      cursor: pointer;
    }
    /* In Mahjong Solitaire, all tiles typically show their face.
       Here, we use .back style only if needed (e.g. if we want to hide them),
       but in our implementation all tiles are shown. */
    .tile.back {
      background-color: #444;
      border: 1px solid #222;
      color: #444;
    }
    /* Highlight a selected tile */
    .tile.selected {
      outline: 3px solid #FFD700;
    }
    
    /* ====================== MESSAGE AREA ====================== */
    /* Display feedback messages below the board. */
    #message {
      margin-top: 20px;
      padding: 8px;
      font-size: 1.1rem;
      position: relative;
      z-index: 10;
    }
    
    /* ====================== HELP MODAL ====================== */
    .modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
    }
    .modal-content {
      background-color: #2a2a2a;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 500px;
      border-radius: 6px;
      text-align: left;
      color: #e0e0e0;
    }
    .close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      color: #ccc;
    }
    .close:hover, .close:focus {
      color: #fff;
    }
    
    /* ====================== FOOTER ====================== */
    footer {
      margin-top: auto;
      padding: 10px 0;
      background-color: #1f1f1f;
      font-size: 0.9rem;
      color: #ccc;
      text-align: center;
    }
    
    /* ====================== RESPONSIVE ====================== */
    @media (max-width: 600px) {
      .tile { width: 60px; height: 75px; font-size: 1.1rem; }
      #board-container { max-width: 100%; height: 400px; }
    }
  </style>
</head>
<body>
  <!-- HEADER -->
  <header>
    <h1>Mahjong Solitaire</h1>
    <button id="helpBtn">Help</button>
    <button id="newGameBtn">New Game</button>
  </header>
  
  <!-- BOARD CONTAINER: The board where all tiles are arranged -->
  <div id="board-container"></div>
  
  <!-- MESSAGE AREA for feedback on moves -->
  <div id="message"></div>
  
  <!-- FOOTER -->
  <footer>
    © 2025 Bocaletto Luca
  </footer>
  
  <!-- HELP MODAL -->
  <div id="helpModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeHelp">&times;</span>
      <h2>How to Play Mahjong Solitaire</h2>
      <p>
        <strong>Goal:</strong> Remove all matching pairs of tiles from the board.<br><br>
        <strong>Rules:</strong><br>
        - Tiles can be removed in pairs if they match exactly.<br>
        - A tile is considered <em>free</em> if it is not covered by any tile from a higher layer and if at least one of its left or right sides is unobstructed.<br>
        - Click a free tile to select it. Then click on a second free tile with the same symbol to remove both tiles.<br>
        - If the two selected tiles do not match, they will be deselected.<br><br>
        Enjoy the game!
      </p>
    </div>
  </div>
  
  <!-- ====================== JAVASCRIPT ====================== -->
  <script>
    /*********************************************
     * Global Variables and Game State
     *********************************************/
    let tiles = [];            // Array of all tile objects
    let selectedTileId = null; // Currently selected tile id (if any)
    
    // Dimensions for each tile. These are used in positions.
    const TILE_WIDTH = 80;
    const TILE_HEIGHT = 100;
    
    /*********************************************
     * Board Layout: Define positions for all tiles.
     * We'll define a two-layer layout:
     * - Layer 0: 28 tiles arranged in a 7x4 grid.
     * - Layer 1: 8 tiles arranged in 2 rows of 4 tiles, centered.
     *********************************************/
    let positions = [];
    // Layer 0: 7 columns, 4 rows. (Total 28 tiles)
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 7; col++) {
        positions.push({
          x: 50 + col * 100, // horizontal spacing
          y: 50 + row * 110, // vertical spacing
          z: 0,              // layer 0
          width: TILE_WIDTH,
          height: TILE_HEIGHT
        });
      }
    }
    // Layer 1: 2 rows, 4 columns (Total 8 tiles), centered.
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < 4; col++) {
        positions.push({
          x: 200 + col * 100, // centered horizontally
          y: 150 + row * 110, // vertical placement
          z: 1,              // layer 1 (on top of layer 0)
          width: TILE_WIDTH,
          height: TILE_HEIGHT
        });
      }
    }
    // Total positions: 28 + 8 = 36
    
    /*********************************************
     * Initialize Game
     * - Create tile pairs (each type appears twice for 36 tiles)
     *********************************************/
    function initGame() {
      tiles = [];
      selectedTileId = null;
      document.getElementById("message").textContent = "";
      
      // Define 18 unique tile types (using letters A-R)
      let types = "ABCDEFGHIJKLMNOPQR".split("");
      // Create an array with each type appearing twice (total should be 36 tiles)
      let tileTypes = [];
      types.forEach(type => {
        tileTypes.push(type);
        tileTypes.push(type);
      });
      shuffle(tileTypes);
      
      // Assign a type to each position
      for (let i = 0; i < positions.length; i++) {
        let pos = positions[i];
        let tile = {
          id: i,
          type: tileTypes[i],
          x: pos.x,
          y: pos.y,
          z: pos.z,
          width: pos.width,
          height: pos.height,
          removed: false
        };
        tiles.push(tile);
      }
      renderTiles();
    }
    
    // Fisher-Yates Shuffle
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    /*********************************************
     * Rendering Functions
     * Renders all tiles based on their properties and current game state.
     *********************************************/
    function renderTiles() {
      let board = document.getElementById("board-container");
      board.innerHTML = "";  // Clear previous rendering
      
      // Sort tiles by z-index (layer) so that tiles on higher layers appear on top
      let sortedTiles = tiles.slice().sort((a, b) => a.z - b.z);
      
      sortedTiles.forEach(tile => {
        if (!tile.removed) {
          let tileDiv = document.createElement("div");
          tileDiv.className = "tile";
          // If this tile is selected, add a highlight
          if (tile.id === selectedTileId) {
            tileDiv.classList.add("selected");
          }
          tileDiv.textContent = tile.type;
          // Position the tile
          tileDiv.style.left = tile.x + "px";
          tileDiv.style.top = tile.y + "px";
          tileDiv.style.zIndex = tile.z;
          // Add click handler to process selection and matching
          tileDiv.onclick = () => handleTileClick(tile.id);
          
          board.appendChild(tileDiv);
        }
      });
    }
    
    /*********************************************
     * Free Tile Detection
     * A tile is free if:
     * 1. No tile on a higher layer (z > current) overlaps it.
     * 2. At least one of its left or right sides is not blocked by a tile on the same layer.
     *********************************************/
    function isTileFree(tile) {
      if (tile.removed) return false;
      
      // Condition 1: Check if any tile on a higher layer overlaps this tile.
      for (let other of tiles) {
        if (!other.removed && other.z > tile.z) {
          if (isOverlap(tile, other)) {
            return false;
          }
        }
      }
      
      // Condition 2: Check for horizontal free sides on same layer.
      let leftBlocked = false;
      let rightBlocked = false;
      for (let other of tiles) {
        if (!other.removed && other.z === tile.z && other.id !== tile.id) {
          if (isTouchingLeft(tile, other)) leftBlocked = true;
          if (isTouchingRight(tile, other)) rightBlocked = true;
        }
      }
      // Tile is free if at least one side is available.
      return (!leftBlocked || !rightBlocked);
    }
    
    // Check if two tiles overlap (bounding box intersection)
    function isOverlap(tile1, tile2) {
      return (tile1.x < tile2.x + tile2.width &&
              tile1.x + tile1.width > tile2.x &&
              tile1.y < tile2.y + tile2.height &&
              tile1.y + tile1.height > tile2.y);
    }
    
    // Check if another tile touches the left side of the current tile.
    function isTouchingLeft(tile, other) {
      if (other.x + other.width >= tile.x - 10 && other.x + other.width <= tile.x + 10) {
        return verticalOverlap(tile, other);
      }
      return false;
    }
    
    // Check if another tile touches the right side of the current tile.
    function isTouchingRight(tile, other) {
      if (other.x <= tile.x + tile.width + 10 && other.x >= tile.x + tile.width - 10) {
        return verticalOverlap(tile, other);
      }
      return false;
    }
    
    function verticalOverlap(tile, other) {
      return (tile.y < other.y + other.height && tile.y + tile.height > other.y);
    }
    
    /*********************************************
     * Tile Selection & Matching
     * Click on a free tile to select it. When a second free tile is clicked,
     * if they match (same type) they are removed. If not, selection is cleared.
     *********************************************/
    function handleTileClick(tileId) {
      let tile = tiles.find(t => t.id === tileId);
      if (!tile || tile.removed) return;
      
      // Check if the tile is free.
      if (!isTileFree(tile)) {
        document.getElementById("message").textContent = "Tile is not free.";
        return;
      }
      
      // If no tile is selected yet, select this tile.
      if (selectedTileId === null) {
        selectedTileId = tileId;
        document.getElementById("message").textContent = "Selected tile " + tile.type + ". Select a matching free tile.";
        renderTiles();
      }
      // If a tile is already selected, check for a match.
      else {
        let firstTile = tiles.find(t => t.id === selectedTileId);
        // If clicking the same tile, deselect.
        if (firstTile.id === tile.id) {
          selectedTileId = null;
          document.getElementById("message").textContent = "";
          renderTiles();
          return;
        }
        // If types match, remove both tiles.
        if (firstTile.type === tile.type) {
          firstTile.removed = true;
          tile.removed = true;
          document.getElementById("message").textContent = "Matched " + tile.type + " pair!";
          selectedTileId = null;
          renderTiles();
          checkWinCondition();
        } else {
          // Mismatched selection; clear selection and show feedback.
          document.getElementById("message").textContent = "Tiles do not match. Try again.";
          selectedTileId = null;
          renderTiles();
        }
      }
    }
    
    /*********************************************
     * Win Condition
     *********************************************/
    function checkWinCondition() {
      let remaining = tiles.filter(t => !t.removed).length;
      if (remaining === 0) {
        document.getElementById("message").textContent = "Congratulations! You win!";
      }
    }
    
    /*********************************************
     * Event Listeners for UI Buttons and Help Modal
     *********************************************/
    document.getElementById("newGameBtn").onclick = function() {
      initGame();
    };
    document.getElementById("helpBtn").onclick = function() {
      document.getElementById("helpModal").style.display = "block";
    };
    document.getElementById("closeHelp").onclick = function() {
      document.getElementById("helpModal").style.display = "none";
    };
    window.onclick = function(e) {
      if (e.target === document.getElementById("helpModal")) {
        document.getElementById("helpModal").style.display = "none";
      }
    };
    
    /*********************************************
     * Initialize the Game
     *********************************************/
    initGame();
  </script>
</body>
</html>
